Рустамов Диёрбек 
Задача 11: 
QR алгоритм в варианте "метода отражений" поиска собственных значений для симметричных матриц, приведение к трехдиагональному виду унитарным подобием методом отражений.
1)
Обрарбатываются следюущие параметры интерфейса 
Usage: evc [input_file_name] [output_file_name] [options]
Where options include:
  -d    print debug messages [default OFF]
  -e    print errors [default OFF]
  -p    print matrix [default OFF]
  -t    print execution time [default OFF]
  -prec=<num>       precision [default - 1e-14]  
  -eps=<num>        'epsilon' [default - 1e-10]
  -max_iter=<num>   limit number of iterations 
                    [default - 0, i.e. not limit]
  -h, -?     print this and exit

Входные данные:
n
а11 а12 ... а1n
...............
an1 an2 ... ann

размерность матрицы и матрица соответсвенно


Выходные данные :
если задача имеет решение данными алгоритмами:
n
е1
е2
...
еn
если нет, то печатаеся 0.

  
программа возвращает:
0 - задача имеет решение данными алгоритмами.
-1 - метод умпрощения не применим к данной задаче.
1 -  метод не сходится за заданное число итераций.

2)
int sim_28_11(int n, double* A, double* tmp, double precision)
приведение к трехдиагональному виду унитарным подобием методом отраженийматрицу за (n-2) шага 
	1. 
	Имеется симметричная матрица A размерности (n*n).Обозначим x_i=(a2i,a3i,a4i,a5i ... ani), столбец который будет под главной дигональю.Существует такой вектор X=((x_i-||x_i||e1)/(||x_i-||x_i||e1||)),такой где e1=(1 0 0 0...0).Размерность матрицы отражения U(X) равна (n-i), где i шаг алгоритма.
	2.
	Матрицу отражений строим следующим образом: U(x) = I - 2*x*x^T, 
	Вид матрицы U
	(I     0   )
	(0     U(x))
	3.
	Сперва матрица А умножается слвева на U, А после справа на А. При умножении слева зануояются элементы в столбце под главной диагональю, и при умножении справа элементы в строек справа от элемента главной диагонали.
	
	Данный алгоритм повторно применяется и к матрице меньшего размера, которая будет состоять уже из матрицы размерности (n-1) без первого столбца и строки.	
	В результате после n-2 шагов матрица будет приведена к почти треугольной матрице.

Подпрограмма получает на вход:
n - размерность заданной матрицы;
А - матрица, которую нужно привести к трехдиагональномц виду
tmp - матрица вспомогательной памяти
precision -  числа меньше считать нулем


3) 
int evc_28_11(int n, int max_iterations, double epsilon, double* A, double* E, double* tmp, double precision)
QR алгоритм в варианте "метода отражений" поиска собственных значений для симметричных матрицПодпрограмма получает на вход:
n - размерность заданной матрицы;
max_iterations -количество максимальных итераций
epsilon - точность
А - матрица, собственные значения которой нужно найти
E - матрица для собственных значений
tmp - матрица вспомогательной памяти
precision -  определяет, числа меньше какого считать нулем

Алгоритм:

	1. выбирается вектор(столбец) из матрицы А, в котором только два элемента не нулевые.
	По вектору А строится вектор Х, который сотстоит из х1 и х2 
		x_1=a(i,i) - sqrt(a1*a1+a2*a2);
		x_2=a(i,j);
		norm=sqrt(x_1^2+x_2^2); 
		x_1=x_1/norm; 
		x_2=x_2/norm;
		при условии что norm отлично от заданного precision

	2. 
		на каждом шаге матрица U, который равен U=I-x*x'. так как вектор х состоит из только двух ненулевых элементов, то нет надобности хранить его в виде отдельного массива n*n. ! Важно, что умножение на матрицу U осуществляется проще умножения матриц n*n. В данном случае изменяется только 2*n значений умножаемой на U матрицы, остальные неизменны потому что U схожа с I.

	3. умножение матрицы U на матрицу А изменяет только 2*n элементов матрицы А в зависимости от номера итерации.
		матрица Q есть произведение матрицы Q на U'
	4.  Каждую итерацию матрица А пересчитывается как произведение матрицы А на Q. В результате матрица А приводится к треугольной матрице.
	
	Данные шаги будут повторяться пока матрица Q не станет диагонально или же разность между собственными значениями на i и i+1 итерации алгоритма будут крайне малы. Тогда программа останавливается с результатом. Результат - собственные значения, хранятся на диагональных элементах матрицы А и в массиве Е.

size_t sim_memsize_28_11(int n) -  возвращает n*n+n*n+n, которая расходуется на построение вектора a_i, для хранения результата умножения матрицы n*n, и для хранения вектора U

size_t evc_memsize_28_11( int n) - возвращает n*n+n*n+2*n, которая расходуется для хранения матрицы Q, для умножения матриц на матрицу U, а также для хранения результата умножения двух матриц


